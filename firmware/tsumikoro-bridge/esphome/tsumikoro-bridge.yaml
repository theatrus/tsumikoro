esphome:
  name: tsumikoro-bridge
  friendly_name: Tsumikoro Bridge
  platformio_options:
    board_build.flash_mode: dio
    build_flags:
      - -I$PROJECT_DIR/src/include
  # Shared bus protocol integration (headers only, sources in component directory)
  includes:
    - ../../shared/tsumikoro_bus/include/

# ESP32 or ESP32-S3 configuration
esp32:
  board: esp32-s3-devkitc-1  # Change to esp32dev for regular ESP32
  framework:
    type: esp-idf
    version: recommended
    sdkconfig_options:
      CONFIG_FREERTOS_HZ: "1000"

# Enable logging
logger:
  level: DEBUG

# Enable Home Assistant API
api:
  encryption:
    key: !secret api_encryption_key

# Enable OTA updates
ota:
  - platform: esphome
    password: !secret ota_password

# WiFi configuration
wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password

  # Enable fallback hotspot (captive portal) in case wifi connection fails
  ap:
    ssid: "Tsumikoro-Bridge Fallback"
    password: !secret ap_password

captive_portal:

# Web server for status
web_server:
  port: 80

# Custom component for motor bridge functionality
external_components:
  - source:
      type: local
      path: ../components

# Status LED
status_led:
  pin: GPIO2

# UART for Tsumikoro bus (RS-485)
# Note: ESPHome uart is only for logging, actual bus uses ESP-IDF UART directly
#uart:
#  tx_pin: GPIO17
#  rx_pin: GPIO16
#  baud_rate: 1000000  # 1Mbaud for bus

# Tsumikoro bridge configuration
# Custom component for bus controller functionality
tsumikoro_bridge:
  id: motor_bridge
  # UART pins for bus (RS-485)
  uart_port: 1  # UART1
  tx_pin: GPIO17
  rx_pin: GPIO16
  de_pin: GPIO18  # Driver Enable (RTS) for RS-485 transceiver
  baud_rate: 1000000  # 1Mbaud
  # Device configuration
  device_id: 0x00  # Controller address
  turnaround_delay: 3  # 3 byte intervals

# NUCLEO-G071RB Test Mode Controls
# Device ID for NUCLEO board
globals:
  - id: nucleo_device_id
    type: int
    restore_value: no
    initial_value: '0x10'

# LED Control Switches
switch:
  - platform: template
    name: "NUCLEO LED ON"
    icon: "mdi:led-on"
    lambda: |-
      return false;  // Stateless switch
    turn_on_action:
      - lambda: |-
          auto bridge = id(motor_bridge);
          uint8_t device_id = id(nucleo_device_id);
          ESP_LOGI("nucleo_test", "Setting NUCLEO LED ON (device 0x%02X)", device_id);
          bridge->nucleo_set_led(device_id, 1);

  - platform: template
    name: "NUCLEO LED OFF"
    icon: "mdi:led-off"
    lambda: |-
      return false;  // Stateless switch
    turn_on_action:
      - lambda: |-
          auto bridge = id(motor_bridge);
          uint8_t device_id = id(nucleo_device_id);
          ESP_LOGI("nucleo_test", "Setting NUCLEO LED OFF (device 0x%02X)", device_id);
          bridge->nucleo_set_led(device_id, 0);

  - platform: template
    name: "NUCLEO LED Auto-Blink"
    icon: "mdi:led-variant-on"
    lambda: |-
      return false;  // Stateless switch
    turn_on_action:
      - lambda: |-
          auto bridge = id(motor_bridge);
          uint8_t device_id = id(nucleo_device_id);
          ESP_LOGI("nucleo_test", "Setting NUCLEO LED Auto-Blink (device 0x%02X)", device_id);
          bridge->nucleo_set_led(device_id, 2);

# Button State Sensor
binary_sensor:
  - platform: template
    name: "NUCLEO Button"
    icon: "mdi:gesture-tap-button"
    lambda: |-
      auto bridge = id(motor_bridge);
      uint8_t device_id = id(nucleo_device_id);
      uint8_t button_state = 0;
      if (bridge->nucleo_get_button(device_id, &button_state)) {
        return button_state == 1;
      }
      return false;

# LED State Sensors
sensor:
  - platform: template
    name: "NUCLEO LED State"
    icon: "mdi:led-outline"
    lambda: |-
      auto bridge = id(motor_bridge);
      uint8_t device_id = id(nucleo_device_id);
      uint8_t led_state = 0;
      uint8_t auto_blink = 0;
      if (bridge->nucleo_get_led(device_id, &led_state, &auto_blink)) {
        return led_state;
      }
      return NAN;
    update_interval: 2s

text_sensor:
  - platform: template
    name: "NUCLEO Auto-Blink Mode"
    icon: "mdi:sync"
    lambda: |-
      auto bridge = id(motor_bridge);
      uint8_t device_id = id(nucleo_device_id);
      uint8_t led_state = 0;
      uint8_t auto_blink = 0;
      if (bridge->nucleo_get_led(device_id, &led_state, &auto_blink)) {
        return auto_blink ? std::string("Enabled") : std::string("Disabled");
      }
      return std::string("Unknown");
    update_interval: 2s
